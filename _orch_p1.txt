/**
 * PS-12: Venue Solver Pipeline Orchestrator
 *
 * Five-layer pipeline for venue planning:
 *
 *   Layer 1 - Initial Generation:   LLM or template-based layout creation
 *   Layer 2 - Hard Constraints:     MIP scheduler for event->room->timeslot
 *   Layer 3 - Soft Optimization:    Parallel Tempering to minimize layout energy
 *   Layer 4 - Diversity Sampling:   MCMC Metropolis-Hastings for layout gallery
 *   Layer 5 - Multi-Objective:      NSGA-II Pareto front (cost / flow / compliance)
 *
 * Each layer can be invoked independently or chained via `runFullPipeline`.
 */

import type {
  SolverPipeline, PlanningRequest, PlanningResult,
  Layout, LayoutWeights, RoomBoundary, ScheduleResult,
  EventSpec, RoomSpec, TimeslotSpec, ParetoSolution,
  FurnitureItem, PRNG,
} from './types.js'
import { DEFAULT_WEIGHTS, CoolingSchedule, TempSpacing, CrossoverType, createPRNG } from './types.js'
import { simulatedAnnealing } from './sa.js'
import { parallelTempering } from './parallel-tempering.js'
import { computeLayoutEnergy, generateLayoutNeighbor } from './energy/layout-energy.js'
import { solveScheduleMIP } from './mip-scheduler.js'
import { sampleLayoutsMH } from './mcmc.js'
import { nsga2 } from './nsga2.js'
import { cmaes } from './cmaes.js'
import { generateTemplateLayout, generateLayoutLLM } from './layout-generation.js'

// ---------------------------------------------------------------------------
// State <-> Item conversion helpers
// ---------------------------------------------------------------------------

/** Values per item in the state vector: x, y, rotation */
const VALUES_PER_ITEM = 3

/**
 * Convert a FurnitureItem[] to a flat Float64Array state vector.
 *
 * Layout: [x1, y1, rot1, x2, y2, rot2, ...]
 */
function itemsToState(items: FurnitureItem[]): Float64Array {
  const state = new Float64Array(items.length * VALUES_PER_ITEM)
  for (let i = 0; i < items.length; i++) {
    const item = items[i]!
    const offset = i * VALUES_PER_ITEM
    state[offset] = item.x
    state[offset + 1] = item.y
    state[offset + 2] = item.rotation
  }
  return state
}

/**
 * Convert a flat Float64Array state vector back to FurnitureItem[].
 *
 * Uses the template items for width, depth, itemType, and seats;
 * overrides x, y, and rotation from the state vector.
 */
function stateToItems(state: Float64Array, template: FurnitureItem[]): FurnitureItem[] {
  const items: FurnitureItem[] = []
  for (let i = 0; i < template.length; i++) {
    const t = template[i]!
    const offset = i * VALUES_PER_ITEM
    items.push({
      x: state[offset]!,
      y: state[offset + 1]!,
      rotation: state[offset + 2]!,
      width: t.width,
      depth: t.depth,
      itemType: t.itemType,
      seats: t.seats,
    })
  }
  return items
}