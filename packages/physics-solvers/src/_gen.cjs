const fs = require('fs');
const p = 'c:/Users/blake/Documents/GitHub/trades-hall-omni-twin/packages/physics-solvers/src/nsga2.ts';
const SQ = "'";
const BT = '`';

let c = '';
function w(s) { c += s + '\n'; }

w('/**');
w(' * PS-8: NSGA-II Multi-Objective Optimization');
w(' *');
w(' * Implements the Non-dominated Sorting Genetic Algorithm II (Deb et al. 2002)');
w(' * with SBX crossover, uniform crossover, polynomial mutation, crowding');
w(' * distance assignment, and deterministic tournament selection.');
w(' *');
w(' * Reference: Deb, Pratap, Agarwal & Meyarivan,');
w(' *   "A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II",');
w(' *   IEEE Transactions on Evolutionary Computation, 6(2), 2002.');
w(' */');
w('');
w('import type { NSGA2Config, ParetoSolution, ObjectiveFunction, PRNG } from ' + SQ + './types.js' + SQ);
w('import { CrossoverType, createPRNG } from ' + SQ + './types.js' + SQ);
w('');
w('// ---------------------------------------------------------------------------');
w('// Internal types');
w('// ---------------------------------------------------------------------------');
w('');
w('interface Individual {');
w('  state: Float64Array');
w('  objectives: Float64Array');
w('  frontRank: number');
w('  crowdingDistance: number');
w('}');
w('');
w('// ---------------------------------------------------------------------------');
w('// Non-dominated sorting (fast approach from Deb et al. 2002)');
w('// ---------------------------------------------------------------------------');
w('');
w('/**');
w(' * Returns true if solution ' + BT + 'a' + BT + ' dominates solution ' + BT + 'b' + BT + ', i.e.');
w(' * a is no worse on every objective AND strictly better on at least one.');
w(' * (All objectives are minimized.)');
w(' */');
w('function dominates(a: Float64Array, b: Float64Array): boolean {');
w('  let strictlyBetter = false');
w('  for (let m = 0; m < a.length; m++) {');
w('    const va = a[m]!');
w('    const vb = b[m]!');
w('    if (va > vb) return false');
w('    if (va < vb) strictlyBetter = true');
w('  }');
w('  return strictlyBetter');
w('}');
w('');
w('/**');
w(' * Performs non-dominated sorting on the population.');
w(' * Returns an array of fronts, where fronts[0] is the Pareto-optimal front.');
w(' * Each individual' + SQ + 's ' + BT + 'frontRank' + BT + ' is updated in place.');
w(' */');
w('function nonDominatedSort(population: Individual[]): Individual[][] {');
w('  const n = population.length');
w('  // S_p: set of individuals that p dominates (stored as indices)');
w('  const dominated: number[][] = new Array<number[]>(n)');
w('  // n_p: domination count for each individual');
w('  const dominationCount = new Int32Array(n)');
w('');
w('  for (let i = 0; i < n; i++) {');
w('    dominated[i] = []');
w('  }');
w('');
w('  const fronts: Individual[][] = []');
w('  const firstFront: Individual[] = []');
w('');
w('  // Build domination structure - compare all pairs');
w('  for (let p = 0; p < n; p++) {');
w('    const pObj = population[p]!.objectives');
w('    for (let q = p + 1; q < n; q++) {');
w('      const qObj = population[q]!.objectives');
w('      if (dominates(pObj, qObj)) {');
w('        dominated[p]!.push(q)');
w('        dominationCount[q]++');
w('      } else if (dominates(qObj, pObj)) {');
w('        dominated[q]!.push(p)');
w('        dominationCount[p]++');
w('      }');
w('    }');
w('  }');
w('');
w('  // Build first front: all individuals with domination count = 0');
w('  for (let i = 0; i < n; i++) {');
w('    if (dominationCount[i] === 0) {');
w('      population[i]!.frontRank = 0');
w('      firstFront.push(population[i]!)');
w('    }');
w('  }');
w('');
w('  fronts.push(firstFront)');
w('');
w('  // Build subsequent fronts by peeling off the current front');
w('  // and decrementing domination counts for successors');
w('  let currentFrontIdx = 0');
w('  while (fronts[currentFrontIdx]!.length > 0) {');
w('    const nextFront: Individual[] = []');
w('    for (const p of fronts[currentFrontIdx]!) {');
w('      const pIdx = population.indexOf(p)');
w('      for (const qIdx of dominated[pIdx]!) {');
w('        dominationCount[qIdx]--');
w('        if (dominationCount[qIdx] === 0) {');
w('          population[qIdx]!.frontRank = currentFrontIdx + 1');
w('          nextFront.push(population[qIdx]!)');
w('        }');
w('      }');
w('    }');
w('    if (nextFront.length === 0) break');
w('    fronts.push(nextFront)');
w('    currentFrontIdx++');
w('  }');
w('');
w('  return fronts');
w('}');

fs.writeFileSync(p, c);
console.log('Part 1 written:', c.length);
